0. 재귀 함수 선언

1. 함수 인자에 해집합을 담을 배열(int*), 배열의 개수를 저장할 변수(int*)를 추가한다.
ex )   int RecurKnapsackSolver(int N, int W, int* arr, int index);

2. 각 함수의 실행 단계에서 분기가 2개로 나눠짐. ex) N 번째 최적해를 구하기 위해선 N번째 아이템을 포함했을 때와 안 포함했을 때의
해의 집합이 2가지 경우가 생김

3. 각 2가지 경우에 대해서 해의 집합을 담을 배열(arr1, arr2)과 개수를 담을 변수 2개(index1, index2)씩 해서 총 4개의 변수를 선언함(배열 2개, 각각의 인덱스 변수 2개)

4. 각각의 경우에 대해 arr1, index1은 N번째 아이템을 포함하지 않았을 때의 호출 인자로,
arr2, index2는 N번째 아이템을 포함했을 때의 인자로 넘겨줌

ex )
int val1 = RecurKnapsackSolver(N - 1, W, arr1, index1);
int val2 = RecurKnapsackSolver(N - 1, W - weights[N], arr2, index2);

5. 그러고 나면 각각의 경우에 대해 반환된 값이 어떤 게 더 큰지 비교할거고
ex )
if (val1 > val2) {
        ...
}

5-1. 만약 N번째 아이템을 포함하지 않는 경우가 더 크면 넘겨줬던 배열과 개수 변수(arr1, index1)를 인자로 받은 배열과 인덱스(arr, index)에 복사
5-2. 만약 N번째 아이템을 포함하는 경우가 더 크면 넘겨줬던 배열과 개수 변수(arr2, index2)를 인자로 받은 배열과 인덱스(arr, index)에 복사하고
거기에 현재 아이템을 추가해줌

ex )
for item1 in arr1 and item in arr, do
    item = item1
	

6. 그러면 arr과 index 는 상위 호출한 함수에서는 또다시 arr1 또는 arr2에 해당함
-> 반복해서 하다보면 결과적으로 각 단계에서 더 큰 value를 가지는 경우의 아이템들을 담은 배열을 상위 호출 함수로부터 받은 배열과 인덱스에 저장하게 되는거고
-> 맨 처음 호출했을 때까지 거슬러 올라가면 최대 아이템을 담은 배열과 인덱스를 받게 됨

예를 들어 아이템이 4개인 경우 함수를 호출했으면
맨 처음 함수를 호출할 때 인자로 value가 최대일 때의 아이템들을 담을 배열과 그 인덱스(개수)를 저장할 변수를 넘겨주겠지?
ex ) int maxVal = RecurKnapsackSolver(int N, int W, int* arr, int* index);

그럼 이 함수는 재귀적으로 자신을 호출하면서 하위 단계까지 비교를 하는 거지
ex ) 맨 처음 호출을 N = 5 로 했다면
N = 4 면서 5번째 아이템을 포함하지 않을 경우
  N = 3이면서 4번째 아이템을 포함하지 않을 경우
    N = 2면서 3번째 아이템을 포함하지 않을 경우
      ...
    N = 2면서 3번째 아이템을 포함할 경우
      ...
  N = 3이면서 4번째 아이템을 포함할 경우
    N = 2면서 3번째 아이템을 포함하지 않을 경우
    N = 2면서 3번째 아이템을 포함할 경우
N = 4 면서 5번째 아이템을 포함했을 경우
  N = 3이면서 4번째 아이템을 포함하지 않을 경우
    N = 2면서 3번째 아이템을 포함하지 않을 경우
      ...
    N = 2면서 3번째 아이템을 포함할 경우
      ...
  N = 3이면서 4번째 아이템을 포함할 경우
    N = 2면서 3번째 아이템을 포함하지 않을 경우
      ...
    N = 2면서 3번째 아이템을 포함할 경우
      ...

대충 이런식으로
그럼 보면 각 단계에서(N 기준으로)
N = 1일때까지 호출을 하겠지?
그러면 N = 2일때 호출한 함수는 N = 1일때 호출한 함수에게 arr1 or arr2 를 넘겨주었을 거고
N = 1 일 때 호출한 함수는 아이템을 포함한 경우에 넘겨받은 arr 에다가 index 번째에 아이템을 하나 추가하고 index값을 하나 증가시킴
그리고 그 때의 가치합을 반환하면
N = 2 일 때 호출한 함수는 N = 1일때 호출한 함수 2가지의 값을 비교할 거고
만약 아이템 2를 포함했을 때의 가치가 더 크다면(arr2, index2를 넘겨줬을 때의 함수)
당연히 가치합이 더 큰 아이템 조합이 arr2라는 거고
N = 3 에서 받은 arr과 index에 arr2와 index2를 복사함
그리고 이 경우에는 아이템 2를 포함하는 경우가 더 크므로,
arr 에다가 아이템 2를 추가함
그럼 N = 3일 때 호출한 함수로 올라가보면
N = 2 일 때 두 가지 경우에 대해 호출한 함수가 또 있겠지
그럼 또다시 그 두 가지 중에 가치합이 더 큰걸 찾아서 현재 배열(arr)에 복사함
그 과정을 N = 5 일때까지 올라가면서 하게 되고
결국 메인함수에서 인자로 전달했던 arr과 index에 최대 가치를 갖는 아이템 조합과 그 개수가 담기게 됨(리턴값은 물론 가치합이고)
